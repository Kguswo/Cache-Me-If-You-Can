# 5. 연결지향형 트랜스포트: TCP

TCP는 신뢰적인 데이터 전송을 어떻게 구현하고 있는가?
- 관련 필드: 오류 검출, 재전송, 누적 확인응답, 타이머, 순서 번호/확인응답 번호

## 5.1 TCP 연결
- 연결지향형: TCP는 핸드셰이크를 통해 두 프로세스 사이의 논리적 연결을 필요로 함
- 전이중 서비스(full-duplex service): 각 호스트는 송신자가 될 수도, 수신자가 될 수도 있음
- 점대점(point-to-point): 단일 송신자와 단일 수신자로 이루어짐, 멀티캐스팅 불가

>여기서 논리적 연결이란 하위의 계층에서는 이 연결 상태를 감지하지 못하고, 오직 종단 시스템 간에만 이루어지는 연결이다.

### 세 방향 핸드셰이크(three-way handshake)
1. 클라이언트 프로세스 -> 서버 프로세스 TCP 연결 요청
2. 서버 프로세스 -> 클라이언트 프로세스 연결 요청 응답
3. 클라이언트 프로세스 -> 서버 프로세스 확인 응답 (페이로드 포함 가능)

### 데이터 교환
1. 송신 프로세스: 소켓을 통해 데이터 스트림 전달 -> TCP
2. TCP: 송신 버퍼(send buffer)로 데이터 전달
3. 세그먼트 크기 결정 후 데이터를 각 세그먼트 단위(데이터+TCP헤더)로 나눔
4. 세그먼트를 IP 데이터그램 안에 각각 캡슐화 네트워크 계층에 전달
5. 수신 버퍼에 세그먼트 도착

#### MSS(maximum segment size)
  - 최대 세그먼트 크기
  - 일반적으로 가장 큰 링크 계층 프레임 길이(MTU:maximum transmission unit)에 의해 결정
  - 이더넷, PPP 프로토콜이 1,500바이트의 MTU -> MSS크기는 보통 1460바이트
  - TCP/IP 헤더 길이가 보통 40바이트

## 5.2 TCP 세그먼트 구조
![세그먼트구조](https://velog.velcdn.com/images/uiseok0514/post/0486e3da-326d-41c7-a37e-5f9af8fdbd03/image.png)

- 헤더 필드 + 데이터 필드로 구성
- MSS에 의해 데이터 필드 크기 제한, 큰 파일의 경우 MSS 크기로 파일 분절
- 헤더는 일반적으로 20바이트(UDP는 8바이트)
- 하지만 텔넷, ssh 같은 원격 로그인에서는 데이터 필드 1바이트 -> 총 21바이트

### 헤더
- 출발지와 목적지 포트 번호: 다중화 역다중화에 필요, 전달할 프로세스 식별
- 체크섬: 오류 검출에 사용
- 순서번호 필드(32비트), 확인응답번호 필드(32비트): 신뢰적 데이터 전송 구현에 필요
- 수신 윈도(receive window, 16비트): 수신 버퍼의 빈 공간, 흐름제어에 사용
- 헤더 길이(header length field, 4비트):
  - 옵션 필드에 의해 가변적이라서 헤더 길이를 알아야 함
  - TCP 헤더길이는 32비트 단위로 측정되며, `헤더길이 필드 값 * 4 = 실제 바이트 단위의 헤더길이`
  - 일반적으로는 옵션 필드를 비우고 20바이트, 옵션필드 추가 시 더 길어질 수 있음
- 옵션 필드(option field, 가변적): MSS 크기 협상 또는 고속 네트워크 사용을 위한 윈도 확장 요소, 타임스탬프 옵션 등
- 플래그 필드(flag field, 6비트):
  - ACK 비트: 성공적으로 수신된 세그먼트에 대한 확인응답
  - RST, SYN, FIN: 연결 설정 및 해제에 관여
  - PSH: 데이터를 상위 계층에 즉시 전달
  - URG: 송신 측 상위 개체가 '긴급'으로 표시하는 데이터

#### 순서번호와 확인응답 번호
- **순서번호 필드**(sequence number field, 32비트): 각 세그먼트의 첫번째 바이트 스트림 넘버
- **확인응답번호 필드**(acknowledgement number field, 32비트): 송신자로부터 기대하는 다음 바이트 스트림 넘버, 순서대로 모두 받은 마지막 바이트까지 누적 확인응답(cumulative acknowledgment) 방식
  - 순서가 바뀌어 도착 시 선택사항
    1. 순서에 맞지 않는 세그먼트를 버림
    2. 세그먼트를 보유하고, 빈 공간 데이터를 기다림(네트워크 대역폭 관점에서 효율적, 실제 사용)

>서버-클라이언트 데이터 세그먼트상에서 확인응답은 피기백된다(piggybacked)고 말함

![예시](https://blog.kakaocdn.net/dn/zY9Mg/btsdO2Y4reS/qLlln61qpzc2T18oxatbz0/img.png)

## 5.3 왕복 시간(RTT) 예측과 타임아웃
타임아웃/재전송: TCP가 손실 세그먼트를 발견하기 위한 매커니즘

### 왕복시간 예측
- SampleRTT: 세그먼트 전송 후 확인응답까지의 시간
  - TCP 연결에서 한 타임에 하나씩 측정 O, 모든 세그먼트에 대해 측정 X, 재전송 측정 X
- EstimatedRTT: 계속해서 불규칙적으로 측정되는 SampleRTT의 평균값, 최근 샘플에 가중치 부여
  - EstimatedRTT = (0.875 * EstimatedRTT) + (0.125 * SampleRTT)
  - 지수적 가중 이동 평균(exponential weighted moving average, EWMA)
- DevRTT: SampleRTT가 EstimatedRTT로부터 얼마나 벗어나는지, RTT 변화율
  - 클수록 SampleRTT 변동폭이 큰것

### 재전송 타임아웃 주기의 설정과 관리
- 타임아웃 주기는 EstimatedRTT보다 약간의 여유가 필요하다. 너무 짧으면 불필요한 재전송, 너무 길면 과도한 지연이 발생한다. SampleRTT 값에 변동이 클수록 여유값이 커야한다.  
즉, `TimeoutInterval = EstimatedRTT + (4 * DevRTT)`로 갱신
- 초기 TimeoutInterval은 1초 권고
- 타임아웃 발생시 TimeoutInterval *= 2, 조기 타임아웃 방지

## 5.4 신뢰적인 데이터 전송
전송하는 데이터 스트림이 손상되지 않고, 손실이나 중복이 없으며, 순서가 유지되는 것을 보장

### 1단계: 1개의 타이머만을 사용
1. 세그먼트를 캡슐화하여 네트워크로 보낼 때, 다른 세그먼트에 의한 타이머 실행이 없다면 타이머를 시작
2. 타임아웃이 발생하면 해당 세그먼트에 대해 재전송, 타이머 재시작
3. 수신확인 응답(ACK)을 받았을 때, 변수 `SendBase(수신확인되지 않은 가장 오래된 바이트 순서) < ACK의 값 y` 이면 SendBase 변수를 갱신하고 해당 위치에서 타이머를 다시 시작한다.

- 시나리오 1: ACK가 손실되어 같은 데이터가 재전송된 경우
  - 수신 버퍼는 중복된 세그먼트를 버린다.
- 시나리오 2: ACK가 지연되어 타임아웃이 먼저 발생한 경우
  - 타이머에 할당되어있던 가장 앞의 세그먼트를 재전송하고 타이머도 재시작한다.
- 시나리오 3: 세그먼트를 2개 보낸다고 가정했을때, 첫번째 ACK만 손실
  - 누적 확인응답 방식을 사용하기 때문에 두번째 ACK만 도착해도 이전의 데이터가 모두 정상적으로 전달되었음을 보장

>타임아웃에 의한 타이머 종료에는 타이머 시간 두배, ACK에 의한 타이머 종료에는 EstimatedRTT와 DevRTT 사용

### 2단계: 빠른 재전송
타이머만 있다면 타임아웃 전까지 재전송을 하지 못한다.
타임아웃이 발생하기 전에 손실을 발견하고 빠르게 재전송하기 위해 중복 ACK의 개수를 센다.

- 누적 확인 응답 방식에서 중복 ACK란 순서에 맞는 세그먼트가 아직 도착하지 않았다는 의미
- 순서가 다르게 도착할수는 있지만 중복 ACK가 지속적으로 반환되는 경우에는 중간 패킷이 손실되었다고 유추할 수 있음
- 3개의 중복 ACK -> ACK 다음 바이트 순서를 전송

### TCP의 오류 제어는 GBN? SR?
두 오류제어 방식을 혼합한 방식이지만 SR에 더 가깝다.
- 전송 후 확인 안된 바이트의 가장 앞 순서(SendBase)와 다음 전송될 바이트 순서(NextSeqNum) 저장
- 수신 버퍼: 순서가 바뀐 올바른 세그먼트 저장
- 손실되었다고 판단된 세그먼트만 재전송
- 이후 전송된 세그먼트에 대한 ACK를 받으면 이전 세그먼트는 모두 정상 수신된 것으로 처리

## 5.5 흐름 제어
수신 프로세스가 데이터를 읽는 속도가 송신 프로세스에서 데이터를 전송하는 속도를 따라가지 못해 수신 버퍼에서 오버플로로 세그먼트 손실이 발생하는 상황을 방지

>RcvBuffer: 수신 버퍼 크기
>LastByteRead: 프로세스에 의해 읽힌 데이터의 마지막 바이트 번호
>LastByteRcvd: 수신 버퍼에 저장된 마지막 바이트 번호
>rwnd: 수신 윈도

`rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]`
![수신윈도](https://velog.velcdn.com/images/yujeongkwon/post/181454a3-b143-4a78-8f27-28f277286bd7/image.png)

- 반환하는 ACK 세그먼트의 '수신윈도우' 필드에 rwnd 값을 설정하여 전달
- 송신 측에서는 ACK에 적힌 확인응답번호와 수신윈도우 필드를 확인하여 확인되기 전의 세그먼트 수를 그보다 적게 유지

#### rwnd = 0인 상태로 수신 측에서 더이상 보낼 메시지가 없을 때
송신 측에서 아직 보낼 데이터가 남아있다면, 수신 측에 1바이트의 데이터로 세그먼트를 계속해서 전송하여 수신윈도우의 값을 요구함

## 5.6 TCP 연결 관리
### 연결 시작
#### 1단계: 클라이언트 TCP -> 서버 TCP 연결 요청 (SYN)
- 데이터 미포함
- SYN 필드 = 1
- 순서 번호(client_isn) 필드 임의 설정

#### 2단계: 서버 TCP -> 클라이언트 TCP 요청 확인 응답 (SYNACK)
- 연결에 TCP 버퍼와 변수 할당(SYN 공격 취약)
- 데이터 미포함
- SYN 필드 = 1
- 확인응답번호 필드 = client_isn + 1
- 순서 번호(server_isn) 필드 임의 설정

#### 3단계: 클라이언트 TCP 연결 승인 수신
- 연결에 TCP 버퍼와 변수 할당
- 데이터 포함 가능
- 확인응답번호 필드 = server_isn + 1

### 연결 종료
#### 1단계: A 프로세스가 B 프로세스에 종료 요청 전송
- 버퍼와 변수 회수
- FIN 필드 = 1

#### 2단계: B 프로세스가 확인응답 전송
#### 3단계: B 프로세스가 A 프로세스에 종료 요청 전송
- 버퍼와 변수 회수
- FIN 필드 = 1

#### 4단계: A 프로세스가 확인응답 전송

### 포트에 해당하는 프로세스가 없는 경우
- 수신 프로세스는 RST 필드 = 1 로 설정하여 반환 (UDP에서는 ICMP 반환)

### nmap 포트 스캐닝 사용시 3가지 결과
1. SYNACK: 요청에 해당하는 TCP포트 사용중, 정상 연결
2. RST: 요청에 해당하는 TCP포트 미사용, 방화벽 없음
3. 아무것도 없음: 방화벽에 의해 막힘