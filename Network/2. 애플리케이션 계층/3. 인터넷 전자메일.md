# 3. 인터넷 전자메일


이 절에서는 인터넷 전자메일 구조의 중심에 있는 애플리케이션 계층 프로토콜을 알아본다.

##### 인터넷 전자 메일 시스템의 상위 레벨 개념
![인터넷 전자 메일 시스템의 상위 레벨 개념](https://github.com/user-attachments/assets/b9512ecf-8d9a-400e-b038-e9f32f57c37c)


<br/>

3가지 주요 요소 : 

1. `User agents` 사용자 에이전트
2. `Mail servers` 메일 서버
3. `SMTP(Simple Mail Transfer Protocol)`

<br/>

### 사용자 에이전트(User Agent, UA)

- 사용자 에이전트는 사용자가 메시지를 읽고, 응답하고, 전달하고, 저장하고, 구성하게 해준다.
- 대표적으로 마이크로 소프트 아웃룩(Outlook), 애플 메일 등이 있다.

<br/>

### 메일 서버(mail server)

- 전자 메일 인프라스트럭처의 중심이다.
- 각 수신자는 메일 서버에 **`메일 박스(mailbox)`** 를 갖고 있다.
    - 메일 박스는 수신자의 메시지를 유지하고 관리한다.
    - **일반 메시지는 송신자의 사용자 에이전트에서 전달이 시작되고, 송신자의 메일 서버를 거친 후에 수신자의 메일 서버로 전달된다.**  
      거기서 수신자의 메일 박스에 저장된다.
    - 전자메일 박스에 있는 메시지를 보려면 메일 서버는 사용자 계정과 비밀 번호를 이용하여 이용자를 인증하여야 한다.
- 송신자는 메일 서버의 고장에도 대처해야 한다.
    - 만약 메일을 수신자의 메일 서버로 전달할 수 없다면 그 메시지를 **`메시지 큐(queue)`** 에 보관하고 나중에 그 메시지를 전달하기 위해 다시 시도한다.
    - 재시도는 약 30분마다 일어나고, 계속 실패 시에 서버는 그 메시지를 제거하고 송신자에게 통보한다.

<br/>


### SMTP

> 인터넷 전자메일을 위한 주요 애플리케이션 계층 프로토콜이다.

- SMTP는 메일을 송신자의 메일 서버로부터 수신자의 메일 서버로 전송하는 데에 `TCP의 신뢰적인 데이터 전송 서비스`를 이용한다.
- SMTP는 대부분의 애플리케이션 계층 프로토콜처럼, `클라이언트`와 `서버`를 갖고 있다.
- SMTP의 클라이언트와 서버 모두가 모든 메일 서버에서 수행되고, 상대 메일로 송신할 때는 클라이언트가 되고 수신할 때는 서버가 된다.

<br/>
<br/>

## 3.1 SMTP

> 메일을 송신자의 메일 서버로부터 수신자의 메일 서버로 전송하는 데 TCP의 신뢰적인 데이터 전송 서비스 이용

<br/>

SMTP에서는 모든 메일 메시지의 몸체는 단순한 `7-bit ASCII`여야 한다.

이 때문에 전송 용량이 제한되어 커다란 첨부 파일이나 비디오 파일을 보낼 때 문제를 일으킨다.

<br/>

전달의 3단계

1. 핸드셰이킹 (greeting)
2. 메시지 전달 (data exchange)
3. 연결 닫기

<br/>

### 기본 동작 과정

##### 앨리스가 밥에게 메시지를 전달
![앨리스가 밥에게 메시지를 전달](https://github.com/user-attachments/assets/5adea4e3-53e2-46fd-a798-aa7aa22e1567)

<br/>

1. 앨리스는 `전자 메일 사용자 에이전트`를 수행하고, 밥의 전자 메일 주소를 제공하여 메시지를 보내라고 명령한다.


2. 앨리스의 사용자 에이전트는 메시지를 그녀의 `메일 서버`에게 보내고, 그곳에서 메시지는 `메시지 큐`에 놓인다.


3. 앨리스의 메일 서버에서 동작하는 SMTP의 클라이언트 측은 메시지 큐에 있는 메시지를 본다.  
   **밥의 메일 서버에서 수행되고 있는 SMTP 서버에게 `TCP 연결`을 설정한다.**


4. 초기 SMTP 핸드셰이킹 이후에 SMTP 클라이언트는 앨리스의 메시지를 TCP 연결로 보낸다.


5. 밥의 메일 서버 호스트에서 SMTP의 서버 측은 메시지를 수신한다. 밥의 `메일 서버`는 그 메시지를 밥의 `메일 박스`에 놓는다.


6. 밥은 편한 시간에 그 메시지를 읽기 위해 `사용자 에이전트`를 시동한다.

<br/>

> SMTP는 두 메일 서버가 먼 거리에 떨어져 있더라도 **중간 메일 서버를 이용하지 않는다.**

즉, 메시지를 보낼 때 보내는데 실패하더라도 중간 메일 서버에 저장되는 것이 아니라 **송신자의 메일 서버에 남아있다.**

<br/>

### 기본 동작 과정 Detail

1. 클라이언트 SMTP는 서버의 SMTP의 `25번 포트`로 `TCP 연결`을 설정한다. 서버가 죽어있다면 나중에 시도한다.


2. 연결이 설정되면, `애플리케이션 계층 핸드셰이킹`을 수행한다.  
   이때 SMTP 클라이언트는 송신자의 전자메일 주소와 수신자의 전자메일 주소를 제공한다.


3. 이후 클라이언트는 메시지를 보낸다. (TCP의 신뢰적인 데이터 전송 서비스에 의존)


4. **보낼 다른 메시지가 있다면 같은 TCP 연결 상에서 반복하며**, 그렇지 않으면 TCP를 닫는다. (`지속 연결(persistent connection)`)

<br/>
<br/>

## SMTP 클라이언트(C)와 SMTP 서버(S) 사이의 메시지 전달 과정 예시

```
S:  220 hamburger.edu
C:  HELO crepes.fr
S:  250 Hello crepes.fr, pleased to meet you
C:  MAIL FROM: <alice@crepes.fr>
S:  250 alice@crepes.fr ... Sender ok
C:  RCPT TO: <bob@hamburger.edu>
S:  250 bob@hamburger.edu ... Recipient ok
C:  DATA
S:  354 Enter mail, end with ”.” on a line by itself
C:  Do you like ketchup?
C:  How about pickles?
C:  .
S:  250 Message accepted for delivery
C:  QUIT
S:  221 hamburger.edu closing connection
```

<br/>

hamburger.edu : SMTP 서버 이름

crepes.fr : SMTP 클라이언트 이름

MAIL FROM : 송신자 이메일 주소

RCPT TO : 수신자 이메일 주소

**이 4개가 SMTP 핸드셰이킹**

<br/>

- 클라이언트는 5개의 `HELO`, `MAIL FROM`, `RCPT TO`, `DATA`, `QUIT` 명령을 내린다.
- 클라이언트는 하나의 점(`.`)으로 된 라인을 송신하며, 그것은 **서버에서 메시지의 끝을 나타낸다.**
- 서버는 각 명령에 응답하며, 각 응답에는 응답 코드와 영문 설명이 있다.

<br/>

**SMTP는 `지속 연결(persistent connection)`을 사용한다.**

즉, 같은 수신 메일 서버로 보내는 여러 메시지를 갖고 있다면, **같은 TCP 연결을 통해 모든 메시지를 전달할 수 있다.**

<br/>
<br/>

## 3.2 메일 메시지 포맷

전자메일을 보낼 때 주변 정보가 포함된 `헤더(header)`가 `메시지 몸체(body)` 앞에 오게 된다.

- 이 헤더는 RFC 5322에 정의되어 있으며, 헤더와 몸체는 CRLF로 분리된다.
- 모든 헤더는 `From:` 헤더라인과 `To:` 헤더 라인을 반드시 가져야 한다. (나머지 헤더는 선택사항이다.)

<br/>

일반 메시지 헤더는 다음과 같다.

```
From: alice@crepes.fr
To: bob@hamburger.edu
Subject: Searching for the meaning of life.

Message
```

<br/>
<br/>

## 3.3 메일 접속 프로토콜(Mail access protocols)

- `SMTP` : delivery / storage to receiver's server
- `Mail access protocol` : retrieval from server

<br/>

> `메일 서버`가 메일 박스를 관리하고, SMTP의 클라이언트와 서버 측 모두를 수행한다.

<br/>

메일 서버가 로컬 호스트에 있다면, 호스트는 언제든 도착할 수 있는 전자 메일을 수신하기 위해 항상 켜져 있어야 하고 인터넷에 연결되어 있어야 한다.

이는 대부분의 인터넷 사용자에게는 비현실적이다.

<br/>

대신에 일반 사용자는 로컬 호스트에서 사용자 에이전트를 수행하고 **늘 켜져 있는 공유 메일 서버에 저장된 메일박스에 접근한다.**

메일 서버는 보통 사용자들과 공유한다.

##### 전자메일 프로토콜과 통신 개체
![전자메일 프로토콜과 통신 개체](https://github.com/user-attachments/assets/5887e5d3-82d6-4b09-a40d-bd06463ebd10)

<br/>

### 송신자 사용자 에이전트에서 수신자 메일 서버까지

> 클라이언트의 사용자 에이전트는 수신자의 메일 서버로 직접 대화하지 않는다.

1. 클라이언트의 사용자 에이전트는 **클라이언트의 메일 서버로 전자메일 메시지를 `SMTP` 또는 `HTTP`를 이용하여 보낸다.**

2. 그리고 수신자의 메일 서버는 **`SMTP`를 이용하여 수신자의 메일 서버로 전자메일 메시지를 중계한다.**

<br/>

두 단계 절차를 거치는 주요 이유는 수신자의 메일 서버를 통해 중계하지 않으면 수신자의 에이전트는 목적지 메일 서버에 도달할 수 없기 때문이다.

송신자는 전자메일을 자신의 메일 서버에 먼저 저장하고, 수신자의 메일 서버는 그 메시지를 수신자의 메일 서버로 받을 때까지 30분 마다 반복해서 보내려고 한다.

<br/>

### 수신자 메일 서버에서 수신자 사용자 에이전트까지

수신자는 자신의 ISP 내부의 메일 서버에 메시지를 어떻게 얻을 수 있는가?

SMTP는 `push` 프로토콜인 반면 메시지를 얻는 것은 `pull` 동작이기 때문에 다른 프로토콜을 사용하여야 한다.

<br/>

두 가지 대표적인 방법

- `HTTP`
    - 웹 기반 전자메일이나 스마트폰 앱의 경우에 쓰인다.
    - 당연히 메일 서버는 SMTP 인터페이스와 HTTP 인터페이스 둘 다 가지고 있어야 한다.
- `IMAP` : RFC 3501에 정의된 인터넷 메일 접근 프로토콜
