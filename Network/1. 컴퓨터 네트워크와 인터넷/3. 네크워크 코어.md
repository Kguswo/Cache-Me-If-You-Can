# 3. 네트워크 코어
> ##### Network Core
![image](https://github.com/user-attachments/assets/42aedc2b-e867-4ec4-b955-2c24eff3eba2)
## 3.1 패킷 교환
- 종단 시스템들은 서로 **`메시지`** 를 교환한다.
1. 출발지 호스트에서 목적지 호스트로 메시지 보내기 위해 송신 시스템은 메시지를 **`패킷 (Packet)`** 이라고 하는 작은 데이터 덩어리로 나눈다.
2. 각 패킷은 **`통신 링크`** 와 **`패킷 스위치`** 를 거친다.
  - 패킷 스위치는 **라우터(router)** 와 **링크 계층 스위치(link-layer switch)** 로 구분된다.
3. 패킷은 링크의 최대 전송률과 같은 속도로 각각의 통신 링크에서 전송된다.
  - 출발지 호스트 or 패킷 스위치가 `R bps`의 속도로 링크에서 `L 비트`의 패킷을 송신한다면, 그 패킷을 전송하는 데 걸리는 시간은 `L/R 초`

### 저장-후-전달
> 스위치가 패킷의 첫 비트를 출력 링크로 전송하기 전에 **전체 패킷**을 받아야 한다.
- 대부분의 패킷 스위치가 사용하는 방식
> ##### Case 1)  하나의 라우터로 연결되고 2개의 종단시스템으로 구성된 네트워크
![image](https://github.com/user-attachments/assets/195f981c-b6ca-4517-b309-5b5cdb82fe5f)
- 라우터는 저장 후 전달 방식을 사용하고 있으므로 수신한 비트를 전송할 수 없다.
- 따라서, 패킷의 비트를 먼저 저장한다. 라우터가 패킷의 모든 비트를 수신하였다면 그제서야 출력 링크로 그 패킷 전송을 시작한다.

#### 경과 시간 (전파 지연 무시)
- `0 초` : 출발지가 패킷 1을 전송하기 시작
- `L/R 초` : 
  - 출발지는 패킷 1의 전체 데이터를 전송 완료. 라우터에 수신되고 저장
  - **라우터가 전체 패킷을 수신했으므로** 라우터는 목적지를 향해 그 패킷을 출력 링크로 전송하기 시작
- `2L/R 초` : 라우터는 전체 패킷을 전송했으며 목적지는 패킷 1 전체를 수신 완료


#### 저장-후-전달 전송 방식을 채택한다면 전체 지연은 `2L/R`, 이 방식 없이 스위치에 비트가 도착하자마자 곧바로 전달을 하게 된다면 전체 지연은 `L/R`

> ##### Case 2) 출발지가 패킷 1을 송신하기 시작한 순간부터 목적지에 3개의 모든 패킷(1, 2, 3)을 수신할 때까지 경과된 전체 시간
![image](https://github.com/user-attachments/assets/d9dd4cd5-79ee-4e94-9cc5-b019ed6d0cf2)
- `0 초` : 출발지가 패킷 1 전송 시작

- `L/R 초` :
  - 라우터는 패킷 1 수신 완료, 1 전송 시작
  - 출발지는 패킷 2 전송 시작
  
- `2L/R 초` :
  - 라우터는 패킷 2를 수신 완료, 2 전송 시작
  - 목적지는 패킷 1 전체 수신 완료
  - 출발지는 패킷 3 전송 시작
  
- `3L/R 초` :
  - 라우터는 패킷 3 수신 완료, 3 전송 시작
  - 목적지는 패킷 2 전체 수신 완료
  
- `4L/R 초` : 목적지는 패킷 3 전체 수신 완료

#### `4L/R` 에 3개의 모든 패킷을 수신하게 된다.

### 종단 간 지연
> #### Case 3) 출발지부터 목적지까지 N개의 링크로 구성되고 각각은 전송률이 R인 경로를 통해 하나의 패킷을 전송하는 경우

종단 간 지연은 다음과 같다.

![image](https://github.com/user-attachments/assets/884a5185-39d8-4b61-8eb8-7230401558dc)

### 큐잉 지연과 패킷 손실
- 각 패킷 스위치는 접속된 여러 링크를 가지고 있다.
- 각 링크에 대해 패킷 스위치는 `출력 버퍼` (출력 큐)를 가지고 있다.
- 그 링크로 송신하려고 하는 패킷 저장.
  - 전송하려는 링크가 다른 패킷 전송하고있으면 도착한 패킷이 출력 버퍼에서 대기하고, `큐잉 지연 (queueing delay)` 을 겪게된다 
- 버퍼 공간의 크기는 유한하기 때문에 버퍼 꽉 차있을 때  `패킷 손실 (packet loss)`이 발생할 수 있다.
  - 버퍼가 전송을 위해 대기 중인 다른 패킷들로 꽉 차 있는 경우 도착하는 패킷 또는 큐에 대기 중인 패킷을 폐기(drop)한다.

> ##### 패킷 스위칭
![image](https://github.com/user-attachments/assets/4a98bf5d-36e0-476a-afcd-863207ead66c)
- 라우터는 15 Mbps의 링크로 수신한 패킷을 전달하고 있는데, 라우터에 도착하는 패킷의 전송률이 15 Mbps보다 빠르면 링크의 출력 버퍼에 패킷들이 큐잉될 것이다 (큐잉 지연).

### 포워딩 테이블과 라우팅 프로토콜
> 라우터는 접속된 통신 링크 중 하나로 도착하는 패킷을 받아서 접속된 통신 링크 중 다른 링크로 그 패킷을 전달한다.

Q. 라우터는 어떻게 그 패킷을 어느 링크로 전달해야 하는지를 결정할까?

#### IP 주소
- 모든 종단 시스템은 IP주소라고 하는 주소를 가진다.
- 출발지는 `패킷의 헤더에 목적지의 IP 주소를 포함` 한다.
- 각 라우터는 목적지 주소(혹은 주소 일부)를 라우터 출력 링크로 매핑하는 `포워딩 테이블` 을 가지고있다.
1. 패킷이 라우터에 도착하면 라우터는 올바른 출력 링크 찾기 위해 주소 조사한다.
2. 이 목적지 주소를 사용해 포워딩 테이블 검색한다.
3. 그 패킷을 출력 링크로 보낸다.

#### 라우팅 프로토콜 (Routing Protocol)
- 각 라우터로부터 각 목적지까지 최단 경로를 결정
- 라우터에 포워딩 테이블 설정할때 이 최단 경로 결과 사용

## 3.2 회선 교환
-종단 시스템 간에 통신을 제공하기 위해
경로상에서 필요한 자원(버퍼, 링크 전송률)은 통신 세션(session) 동안에 확보 또는 `예약(reserve)`된다.
- 세션 메시지는 `온디맨드(on-demand)` 방식으로 자원을 요청
- ex) 전화망
  1. 송신자가 정보를 보내기 전에 네트워크는 송신자와 수신자 간의 연결을 설정
  2. 네트워크가 회선을 설정할 때, 그 연결이 이루어지는 동안 네트워크 링크에 일정한 전송률을 예약
  3. 송신자-수신자 연결을 위해 예약되기 때문에, 송신자는 수신자에게 `보장된(guaranteed)` 일정 전송률로 데이터 전송 가능

#### 종단 간 연결(end-to-end connection)
> ##### Case) 4개의 스위치와 4개의 링크로 구성된 회선 교환 네트워크
![image](https://github.com/user-attachments/assets/a2d49b7a-0e0f-4da4-aa3d-9de4425ca14e)
- 4개의 스위치와 4개의 링크에 연결되어있고 각 링크는 4개의 회선을 가지므로 각 링크는 4개의 동시 연결 지원가능하다.
- 만약 그림처럼 첫번째 링크의 2번째 회선 사용하고 두번째 링크의 4번째 회선 사용하면 (한 회선씩 예약), 각 링크에 대해 그 연결은 연결이 지속되는 동안 `링크 전체 전송 용량의 1/4`를 얻는다

#### Q. 반대로, 한 호스트가 인터넷 같은 패킷 교환 네트워크를 통해 다른 호스트로 패킷을 보내고자 하는 경우에는 어떤 일이 발생할까?
- 회선 교환과 마찬가지로 패킷은 일련의 통신 링크를 통해 전송된다. 그러나 회선 교환과는 달리 패킷 교환은 링크 자원을 예약하지 않고 네트워크로 보내진다.
- 일정 시간 내에 전달하는걸 보장하지는 않는다.

### 회선 교환 네트워크에서의 다중화
1. **`주파수 분할 다중화(Frequency-Division Multiplexing, FDM)`** : 링크를 통해 설정된 연결은 그 링크 주파수 스펙트럼 공유. 연결되는동안 각 연결에 대해 주파수 대역 고정 제공.

    ![image](https://github.com/user-attachments/assets/e03bf3d1-f0db-4990-bc62-94bf24c9687c)
2. **`시분할 다중화(Time-Division Multiplexing, TDM)`** : 시간을 일정 주기의 `프레임`으로 구분하고, 각 프레임은 고정된 수의 시간 `슬롯`으로 나뉜다. 하나의 연결 설정할 때 시간 슬롯 1개를 그 연결에 할당한다. 데이터 전송하기 위해 모든 프레임에 하나의 슬롯을 갖는다. 

    ![image](https://github.com/user-attachments/assets/992a8854-c83e-4268-af0e-376000f17a0b)

### 패킷 교환 대 회선 교환
**[ 패킷 교환 옹호자 ]**
- 주장 1 : 패킷 교환이 회선 교환보다 전송 용량의 공유에서 더 효율적이다.
- 주장 2 : 패킷 교환이 더 간단하고 효율적이며, 구현 비용이 적다.
- Why?
  - 근거 1 : 회선 교환에서 통신을 위해서는 자원이 항상 각각의 사용자에게 예약되어야만 한다.
  - 근거 2 : 할당된 회선이 `비활용 기간(silent period)`에는 자원을 점유한 채로 놀게 되기 때문에 자원 이용률이 감소한다.
  - 근거 3 : 즉, 회선 교환에서는 사용되지 않는 네트워크 자원은 다른 진행 중인 연결이 대신해서 사용할 수 없기 때문이다.

**[ 패킷 교환 반대자 ]**
- 주장 : 패킷 교환은 실시간 서비스에는 적당하지 않다.
- 근거 : 주로 큐잉 지연에서 발생하는 종단 간의 지연 (불규칙적이고 예측할 수 없음)

#### Case 1) 사용자가 1 Mbps 링크를 공유한다. 각 사용자들은 활동 시간(100kbps)과 비활동 시간을 반복한다고 하자.사용자는 전체 시간에서 10%만 활동하며 나머지 90% 시간에는 활동하지 않는다.

- **`회선 교환`** : 100 kbps가 항상 각각의 사용자에게 예약되어야 한다. 그러므로 동시에 10명(= 1 Mbps / 100 kbps)만 지원할 수 있다. 

- **`패킷 교환`** : 10명 이하의 동시 사용자가 있다면 그 확률은 99.96%, 데이터의 통합 도착률은 1 Mbps(링크의 출력률)보다 작거나 같다. 따라서 10명 이상의 동시 사용자가 있다면 패킷의 통합 도착률이 링크의 출력 용량을 초과하기 때문에 출력 큐가 커지기 시작한다. (이 큐는 통합 입력률이 1 Mbps 이하로 떨어질 때까지 커질 것이고, 이후에는 큐 길이가 줄어들기 시작할 것)

10명 이상의 동시 사용자가 있을 확률은 0.04%로 굉장히 작으므로,
패킷 교환은 거의 항상 회선 교환과 대등한 지연 성능을 가지면서도 거의 3배 이상의 사용자 수를 허용한다.

#### Case 2) 10명의 사용자가 있고 1번과 동일하게 사용자는 1 Mbps 링크를 공유한다. 한 사용자가 한번에 1,000비트 패킷을 1,000개 생성하고 다른 사용자는 패킷을 생성하지 않는다.

- **`회선 교환`** : 한 프레임은 10개 슬롯으로 구성되고 각 슬롯은 1,000비트로 구성되었다면 사용자는 데이터 전송을 위해 한 프레임당 1개의 시간 슬롯만 사용할 수 있다. 반면에 각 프레임에 남겨진 9개의 시간 슬롯은 쉬는 상태가 된다.따라서 사용자의 데이터 100만 비트를 모두 전송하려면 `10초`가 걸린다. 

- **`패킷 교환`** : 패킷을 생성하는 다른 사용자가 없기 때문에 다중화가 요구되지 않고, 사용자는 1 Mbps의 링크가 가득 찰 때까지 패킷을 계속 보낼 수 있다. 따라서 사용자의 데이터 100만 비트는 `1초` 만에 모두 전송된다.

#### 결론적으로 패킷 교환이 회선 교환보다 성능이 우수하다.

정리하자면
- 회선 교환 방식 : 요구에 관계없이 미리 전송 링크의 사용을 할당한다.
- 패킷 교환 방식 : 요구할 때만 링크의 사용을 할당한다.

## 3.3 네트워크의 네트워크
### 접속 ISP
- 다양한 접속기술을 이용해 유선 혹은 무선 연결 제공
- 종단 시스템은 접속 ISP를 통해 인터넷에 연결

> 중요한 목표 : 모든 종단 시스템이 서로에게 패킷을 보낼 수 있도록 접속 ISP를 연결하는 것
- 가장 간단하게는 각 서로다른 접속 ISP를 직접 연결
- 이런 그물망 구조는 매우 비용이 큼

### 네트워크 구조 1
> 모든 접속 ISP를 하나의 `글로벌 통과(transit)` ISP와 연결한다.

- 글로벌 통과 ISP : 라우터 + 전 세계에 이르고, 적어도 수십만 개의 접속 ISP와 가까운 곳에 있는 라우터를 갖는 통신 링크의 네트워크
  - 접속 ISP는 `고객(customer)`
  - 글로벌 ISP는 `제공자(provider)`
- 매우 많은 비용

### 네트워크 구조 2
> 수십만개의 접속 ISP와 다중의 글로벌 ISP로 구성
- `2계층구조`
  - 상위층에는 글로벌 ISP 서비스 제공자가 있다.
  - 하위층에는 접속 ISP가 있다.
- 글로벌 ISP들은 서로 연결해야만 한다. 서로 연결되지 않으면 하나의 글로벌 ISP와 연결된 접속 ISP는 다른 글로벌 통과 서비스 제공자에 연결된 접속 ISP와 통신할 수 없다.

#### 지역 ISP와 1계층 ISP
- 어느 주어진 지역에서 그 지역에 있는 접속 ISP들이 연결하는 `지역(regional) ISP`가 존재하며, 각 지역 ISP는 `1계층(tier-1) ISP`들과 연결된다.

### 네트워크 구조 3
> `다중계층구조` (접속 ISP, 지역 ISP, 1계층 ISP)

- 여러 경쟁적인 1계층 ISP들이 존재, 한 지역에 여러 경쟁적인 지역 ISP들이 존재

- 계층구조 각 레벨에 고객-제공자 관계가 존재한다.
  - 각각의 접속 ISP는 자신이 연결하는 지역 ISP에게 요금을 지불한다.
  - 각 지역 ISP는 자신이 연결하는 1계층 ISP에게 요금을 지불한다.
  - 1계층 ISP는 계층구조의 최상위에 있기 때문에 아무에게도 요금을 지불하지 않는다.

### 네트워크 구조 4
> `다중계층구조` (접속 ISP, 지역 ISP, 1계층 ISP) + `PoP + 멀티홈 + 피어링 + IXP`

오늘날의 인터넷과 좀 더 유사한 네트워크를 구축하기 위해서는 네트워크 구조 3에 아래 4가지 항목들을 포함해야 한다.

#### PoP(Points of Presence)

- 제공자의 네트워크 내에 있는 하나 혹은 그 이상의 라우터 그룹
- 최하위(접속 ISP) 계층을 제외한 모든 계층에 존재하며, 고객 ISP가 제공자 ISP에 연결될 수 있다.
- 고객 네트워크가 제공자의 PoP에 연결되기 위해, 고객은 자신의 라우터 중 하나를 PoP에 있는 라우터에 직접 연결하도록 고속 링크를 제3자(third-party) 통신 서비스 제공자로부터 임대할 수 있다.

#### 멀티홈(multi-homing)

- 둘 혹은 그 이상의 제공자 ISP에 연결하도록 선택
- ex) 한 접속 ISP가 2개의 ISP에 연결, 2개의 지역 ISP와 함께 하나의 1계층 ISP에 연결
- 1계층 ISP를 제외한 모든 ISP는 멀티홈을 선택할 수 있다.
- 한 ISP가 멀티홈을 하면 서비스 제공자 중 하나가 연결되지 않더라도 인터넷으로 패킷을 계속 송수신할 수 있게 된다.

#### 피어링(peering)

- 고객 ISP가 서비스 제공 ISP에게 지불하는 요금을 줄이기 위해 인터넷 계층구조의 같은 계층에 있는 가까운 ISP들은 피어링할 수 있다.

- 송수신되는 모든 트래픽을 상위 계층 ISP를 통하지 않고 직접 송수신할 수 있도록 자신들의 네트워크를 서로 직접 연결하는 것

- 1계층 ISP들도 서로 피어링할 수 있다.
 
#### IXP(Internet Exchange Point)

- 다중의 ISP들이 서로 피어링할 수 있는 만남의 장소
- 일반적으로 교환기를 갖춘 독자적인 빌딩에 존재

### 네트워크 구조 5
![image](https://github.com/user-attachments/assets/e4724b93-11e3-480e-b06f-6e6417381286)
> `다중계층구조` (접속 ISP, 지역 ISP, 1계층 ISP) + PoP + 멀티홈 + 피어링 + IXP + `콘텐츠 제공 네트워크`

- 구글
- 구글 데이터 센터는 모두 구글의 사설 TCP/IP 네트워크를 통해 연결되어 있다.
- 구글 사설 네트워크는 구글 서버로 오가는 트래픽만 전달한다.
- 많은 접속 ISP는 여전히 1계층 네트워크를 통해서만 도달할 수 있기 때문에 구글 네트워크도 1계층 ISP들과 연결하고 그들과 교환하는 트래픽에 대해 이 ISP들에게 요금을 지불한다.
- 콘텐츠 제공자들이 자신의 네트워크를 구축함으로써 얻는 이점
  - 상위 계층 ISP들에게 지불하는 요금을 줄일 수 있다.
  - 최종 사용자들에게 자신들의 서비스가 궁극적으로 어떻게 전달되는지에 대한 더 많은 통제권을 가질 수 있다.
